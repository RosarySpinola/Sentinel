# Prompt 1: PostgreSQL Database Schema & Integration

**Priority**: HIGHEST
**Skill**: api-dev

---

## Pre-Task: Read Relevant Issues

Before starting, check for documented issues:
```bash
cat docs/issues/tooling/README.md
```

If issues exist related to database or Prisma, read them first to avoid known pitfalls.

---

## Objective

Set up PostgreSQL database with Prisma ORM for the Rust API backend. This provides persistence for users, projects, simulations, and prover runs.

---

## Current State

- `api/` - Rust backend with no database
- `api/Cargo.toml` - No database dependencies
- No schema definition exists

---

## Requirements

### 1. Add Database Dependencies to Rust API

Add to `api/Cargo.toml`:
- `sqlx` with postgres feature for async database access
- `uuid` for ID generation
- `dotenvy` for environment config

### 2. Create Database Schema

Create SQL migration files for these tables:

**users**
- `id` UUID PRIMARY KEY
- `clerk_id` VARCHAR(255) UNIQUE NOT NULL (links to Clerk auth)
- `email` VARCHAR(255) NOT NULL
- `name` VARCHAR(255)
- `created_at` TIMESTAMP DEFAULT NOW()
- `updated_at` TIMESTAMP DEFAULT NOW()

**projects**
- `id` UUID PRIMARY KEY
- `user_id` UUID REFERENCES users(id) ON DELETE CASCADE
- `name` VARCHAR(255) NOT NULL
- `description` TEXT
- `network` VARCHAR(50) DEFAULT 'testnet'
- `created_at` TIMESTAMP DEFAULT NOW()
- `updated_at` TIMESTAMP DEFAULT NOW()

**simulations**
- `id` UUID PRIMARY KEY
- `project_id` UUID REFERENCES projects(id) ON DELETE CASCADE
- `user_id` UUID REFERENCES users(id)
- `sender` VARCHAR(66) NOT NULL
- `module_address` VARCHAR(66) NOT NULL
- `module_name` VARCHAR(255) NOT NULL
- `function_name` VARCHAR(255) NOT NULL
- `args` JSONB
- `type_args` JSONB
- `result` JSONB NOT NULL (full simulation result)
- `success` BOOLEAN NOT NULL
- `gas_used` BIGINT
- `network` VARCHAR(50) NOT NULL
- `created_at` TIMESTAMP DEFAULT NOW()

**prover_runs**
- `id` UUID PRIMARY KEY
- `project_id` UUID REFERENCES projects(id) ON DELETE CASCADE
- `user_id` UUID REFERENCES users(id)
- `module_name` VARCHAR(255) NOT NULL
- `move_code` TEXT NOT NULL
- `status` VARCHAR(50) NOT NULL (passed/failed/timeout/error)
- `duration_ms` BIGINT
- `result` JSONB NOT NULL (full prover result)
- `created_at` TIMESTAMP DEFAULT NOW()

**api_keys**
- `id` UUID PRIMARY KEY
- `user_id` UUID REFERENCES users(id) ON DELETE CASCADE
- `name` VARCHAR(255) NOT NULL
- `key_hash` VARCHAR(255) NOT NULL (hashed API key)
- `key_prefix` VARCHAR(10) NOT NULL (first 8 chars for display)
- `last_used_at` TIMESTAMP
- `created_at` TIMESTAMP DEFAULT NOW()
- `expires_at` TIMESTAMP

### 3. Create Database Module in Rust

Structure:
```
api/src/
├── db/
│   ├── mod.rs           # Module exports
│   ├── pool.rs          # Connection pool setup
│   ├── users.rs         # User CRUD operations
│   ├── projects.rs      # Project CRUD operations
│   ├── simulations.rs   # Simulation storage
│   ├── prover_runs.rs   # Prover run storage
│   └── api_keys.rs      # API key management
```

### 4. Create Database Pool

In `api/src/db/pool.rs`:
- Create async connection pool with sqlx
- Read `DATABASE_URL` from environment
- Set pool limits (min: 2, max: 10)
- Add health check function

### 5. Update Main.rs

- Initialize database pool at startup
- Pass pool to routes via app state
- Add graceful shutdown

### 6. Create Environment Template

Create `api/.env.example`:
```
DATABASE_URL=postgres://user:password@localhost:5432/sentinel
RUST_LOG=info
PORT=3001
```

---

## Files to Create/Modify

- `api/Cargo.toml` - MODIFY - Add sqlx, uuid, dotenvy
- `api/migrations/001_initial.sql` - CREATE - Full schema
- `api/src/db/mod.rs` - CREATE - Module exports
- `api/src/db/pool.rs` - CREATE - Connection pool
- `api/src/db/users.rs` - CREATE - User operations
- `api/src/db/projects.rs` - CREATE - Project operations
- `api/src/db/simulations.rs` - CREATE - Simulation storage
- `api/src/db/prover_runs.rs` - CREATE - Prover run storage
- `api/src/db/api_keys.rs` - CREATE - API key operations
- `api/src/main.rs` - MODIFY - Add DB pool to state
- `api/.env.example` - CREATE - Environment template

---

## Verification

```bash
# 1. Check Cargo.toml compiles
cd api && cargo check

# 2. Run with a test database (if Docker available)
docker run --name sentinel-db -e POSTGRES_PASSWORD=test -e POSTGRES_DB=sentinel -p 5432:5432 -d postgres:15

# 3. Run migrations
export DATABASE_URL="postgres://postgres:test@localhost:5432/sentinel"
sqlx database create
sqlx migrate run

# 4. Verify tables exist
psql $DATABASE_URL -c "\dt"
```

---

## Success Criteria

- [ ] Cargo compiles without errors
- [ ] All 5 tables defined in migration
- [ ] Pool module connects to database
- [ ] Each table has CRUD functions
- [ ] Environment template exists
- [ ] All files under 300 lines

---

## Dependencies

- **Requires**: None (first prompt)
- **Blocks**: Prompt 2 (Authentication), Prompt 3 (Projects), Prompt 4 (History)

---

## Document Issues

If you encounter problems during implementation, document them:
```bash
# Add to docs/issues/tooling/README.md
```

Format:
```markdown
## TOOL-001: [Issue Title]
**Problem**: What happened
**Root Cause**: Why it happened
**Solution**: How to fix it
**Prevention**: How to avoid in future
```
