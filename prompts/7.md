# Prompt 7: Redis Caching Layer

**Priority**: Medium
**Skill**: api-dev

---

## Pre-Task: Read Relevant Issues

Before starting, check for documented issues:
```bash
cat docs/issues/tooling/README.md
```

---

## Objective

Add Redis caching to improve performance and reduce RPC load. Cache simulation results, module metadata, and account states. Implement cache invalidation strategies.

---

## Current State

- Rust API makes direct RPC calls every request
- No caching of any kind
- Same simulation can be run multiple times

---

## Requirements

### 1. Add Redis Dependencies

Add to `api/Cargo.toml`:
- `redis` with tokio-comp feature
- `deadpool-redis` for connection pooling

### 2. Create Redis Module

Create `api/src/cache/mod.rs`:
```rust
mod pool;
mod keys;
mod simulation;
mod module_cache;
pub use pool::*;
pub use keys::*;
pub use simulation::*;
pub use module_cache::*;
```

### 3. Create Redis Pool

Create `api/src/cache/pool.rs`:
- Create connection pool from `REDIS_URL` env
- Default: `redis://localhost:6379`
- Pool size: 5-20 connections
- Health check function

### 4. Create Cache Key Schema

Create `api/src/cache/keys.rs`:
```rust
// Key patterns:
// sim:{network}:{hash}        - Simulation result (24h TTL)
// mod:{network}:{address}     - Module ABI (1h TTL)
// acc:{network}:{address}     - Account resources (5min TTL)
// rate:{user_id}              - Rate limit counter (1min TTL)

pub fn simulation_key(network: &str, payload_hash: &str) -> String;
pub fn module_key(network: &str, address: &str) -> String;
pub fn account_key(network: &str, address: &str) -> String;
pub fn rate_limit_key(user_id: &str) -> String;
```

### 5. Create Simulation Cache

Create `api/src/cache/simulation.rs`:
- `get_cached_simulation(key)` -> Option<SimulationResult>
- `cache_simulation(key, result, ttl)` -> Result<()>
- `hash_simulation_request(request)` -> String (deterministic hash)
- TTL: 24 hours for successful, 5 min for failed

### 6. Create Module Cache

Create `api/src/cache/module_cache.rs`:
- `get_cached_module(network, address)` -> Option<ModuleABI>
- `cache_module(network, address, abi)` -> Result<()>
- Caches function signatures and type info
- TTL: 1 hour

### 7. Create Rate Limiter

Create `api/src/cache/rate_limit.rs`:
- `check_rate_limit(user_id, limit, window_secs)` -> Result<RateLimitResult>
- Uses Redis INCR with EXPIRE
- Returns: allowed, remaining, reset_at

```rust
pub struct RateLimitResult {
    pub allowed: bool,
    pub remaining: u32,
    pub limit: u32,
    pub reset_at: u64,
}
```

### 8. Apply Caching to Simulation

Modify `api/src/simulation/executor.rs`:
1. Before RPC call, check cache
2. If cached result exists and not expired, return it
3. If not cached, make RPC call
4. Cache successful result
5. Return result

### 9. Apply Rate Limiting

Modify `api/src/auth/middleware.rs`:
- After API key validation, check rate limit
- Default limits:
  - Free tier: 100 requests/minute
  - Pro tier: 1000 requests/minute
- Return 429 Too Many Requests if exceeded
- Include headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset

### 10. Add Cache Stats Endpoint

Create `api/src/routes/cache.rs`:
- GET /api/v1/cache/stats (admin only)
- Returns: hit_rate, total_keys, memory_usage

### 11. Update Environment Template

Add to `api/.env.example`:
```
REDIS_URL=redis://localhost:6379
RATE_LIMIT_FREE=100
RATE_LIMIT_PRO=1000
```

---

## Files to Create/Modify

- `api/Cargo.toml` - MODIFY - Add redis, deadpool-redis
- `api/src/cache/mod.rs` - CREATE
- `api/src/cache/pool.rs` - CREATE
- `api/src/cache/keys.rs` - CREATE
- `api/src/cache/simulation.rs` - CREATE
- `api/src/cache/module_cache.rs` - CREATE
- `api/src/cache/rate_limit.rs` - CREATE
- `api/src/simulation/executor.rs` - MODIFY - Add cache check
- `api/src/auth/middleware.rs` - MODIFY - Add rate limiting
- `api/src/routes/cache.rs` - CREATE
- `api/src/routes/mod.rs` - MODIFY
- `api/src/main.rs` - MODIFY - Initialize Redis pool
- `api/.env.example` - MODIFY

---

## Cache Key Examples

```
# Simulation cache
sim:testnet:abc123def456...

# Module ABI cache
mod:mainnet:0x1::coin

# Account state cache
acc:testnet:0x1234...abcd

# Rate limit counter
rate:user_abc123
```

---

## Verification

```bash
# 1. Start Redis locally
docker run --name sentinel-redis -p 6379:6379 -d redis:7

# 2. Cargo compiles
cd api && cargo check

# 3. Test cache miss -> hit
curl -X POST http://localhost:3001/api/v1/simulate ...
# Check response time: ~500ms

curl -X POST http://localhost:3001/api/v1/simulate ...
# Same request, check response time: ~10ms (cached)

# 4. Test rate limiting
for i in {1..110}; do curl -s -o /dev/null -w "%{http_code}\n" ...; done
# Should see 429 after 100 requests

# 5. Check Redis keys
redis-cli KEYS "sim:*"
```

---

## Success Criteria

- [ ] Redis pool connects successfully
- [ ] Simulation results are cached
- [ ] Cache hit returns in <50ms
- [ ] Rate limiting works per user
- [ ] 429 response includes rate limit headers
- [ ] Module ABIs are cached
- [ ] Cache expires correctly
- [ ] All files under 300 lines

---

## Dependencies

- **Requires**: Prompt 1 (Database for user tiers), Prompt 6 (API keys)
- **Blocks**: Prompt 8 (Deployment needs Redis)

---

## Performance Targets

| Operation | Without Cache | With Cache |
|-----------|--------------|------------|
| Simulation | 200-500ms | <50ms |
| Module ABI | 100-200ms | <10ms |
| Account State | 50-100ms | <10ms |

---

## Cache Invalidation

- Simulation: Time-based (24h)
- Module ABI: Time-based (1h), invalidate on new deployment
- Account State: Time-based (5min)
- Rate limits: Auto-expire after window

No manual invalidation UI needed for MVP.
